#include "config.hh"
#include "lexer.hh"
//#include "parser.hh"
//#include "rocken.hh"

#include <fmt/color.h>
#include <fmt/core.h>

#include <map>
#include <optional>
#include <vector>

#include <iostream>
#include <string>

struct Command {
    std::string name;
    std::vector<std::string> args;
};

std::map<std::string, std::string> help_text;

std::optional<Command> parse_command_line(int argc, char **argv) {
    if (argc < 2) { return std::nullopt; }

    Command command;
    command.name = argv[1];

    for (int i = 2; i < argc; i++) {
        command.args.push_back(argv[i]);
    }

    return command;
}

void print_help(const std::string &command_name) {
    if (help_text.empty()) {
        help_text["build"] = "compile packages and dependencies";
        help_text["clean"] = "remove object files and clear build cache";
        help_text["doc"] = "display documentation for a package or symbol";
        help_text["env"] = "prints the environment information";
        help_text["fmt"] = "reformat package sources";
        help_text["install"] = "build and install packages and dependencies";
        help_text["run"] = "runs a program file";
        help_text["repl"] = "runs Brocken in a REPL. Same as running without a command";
        help_text["new"] = "creates a new module";
        help_text["test"] = "runs your test suite";
        help_text["version"] = "prints Brocken's version";
    }

    if (command_name.empty()) {
        fmt::print("Brocken. Squint.\n\nUsage:\n\n        brocken <command> [arguments]\n\n");
        fmt::print("Commands include:\n\n");
        for (const auto &[command, help] : help_text) {
            fmt::print("        {:<10} {}\n", command, help);
        }
        fmt::print("\nTry `brocken help <command>` for more information about a command\n\n");
        //~ fmt::print("Additional help topics:\n\n");

        /* generated by a script internally
        Additional help topics:

                buildmode       build modes
                ffi             foreign functions written in C, Rust, Fortran, etc.
                cache           build and test caching
                filetype        file types
                go.mod          the go.mod file
                gopath          GOPATH environment variable
                gopath-get      legacy GOPATH go get
                goproxy         module proxy protocol
                importpath      import path syntax
                modules         modules, module versions, and more
                module-get      module-aware go get
                module-auth     module authentication using go.sum
                packages        package lists and patterns
                private         configuration for downloading non-public code
                testflag        testing flags
                testfunc        testing functions
                vcs             controlling version control with GOVCS

        Use "go help <topic>" for more information about that topic.
                */
    }
    else {
        // Print help for the specified command.
        auto help = help_text.find(command_name);
        if (help != help_text.end()) { fmt::print("{}\n", help->second); }
        else { fmt::print("Unknown command: {}\n", command_name); }
    }
}

#if 0
#if HAS_COROUTINE
#include <cassert>
#ifdef __APPLE__
#include <experimental/coroutine>
std::experimental::coroutine_handle
#else
#include <coroutine>
#endif
#include <thread>
    auto
    switch_to_new_thread(std::jthread &out) {
    struct awaitable {
        std::jthread *p_out;
        bool await_ready() { return false; }
#if __APPLE__
        void await_suspend(std::experimental::coroutine_handle<> h){
#else
        void await_suspend(std::coroutine_handle<> h) {
#endif
            std::jthread &out = *p_out;
        if (out.joinable()) throw std::runtime_error("Output jthread parameter not empty");
        out = std::jthread([h] { h.resume(); });
    } void await_resume() {}
};
return awaitable{&out};
}

struct task {
    struct promise_type {
        struct task get_return_object() {
            return {};
        }
        std::suspend_never initial_suspend() { return {}; }
        std::suspend_never final_suspend() noexcept { return {}; }
        void return_void() {}
        void unhandled_exception() {}
    };
};

struct task resuming_on_new_thread(std::jthread &out) {
    auto starting_tid = std::this_thread::get_id();
    // suspends coroutine
    co_await switch_to_new_thread(
        out); ///< [co_await](https://en.cppreference.com/w/cpp/keyword/co_await)
    // awaiter is destroyed here
    assert(std::this_thread::get_id() != starting_tid);
}

void coroutine_demo() {
    std::jthread out;
    resuming_on_new_thread(out);
}
#endif // HAS_COROUTINE
#endif // 0
int main(int argc, char **argv) {
    std::string about =
        fmt::format("{} {} ({}:{}) on {}\n",
                    fmt::styled("Brocken", fmt::fg(fmt::color::white) | fmt::emphasis::bold),
                    BROCKEN_VERSION, BROCKEN_GIT_BRANCH, BROCKEN_GIT_COMMIT, BROCKEN_plat);

    std::optional<Command> command = parse_command_line(argc, argv);

    if (!command.has_value() || command->name == "repl") { // Start the REPL.
        std::u32string code = U"=+(){},;";
        Rocken::Lexer lex = Rocken::Lexer(code);
        if (lex.nextToken() == Rocken::Token{Rocken::TokenType::ASSIGN, U"="}) { ; }

        bool repl_flag{false};
        std::string_view file;

        if (!file.size()) {
            fmt::print("{}", about);
            fmt::print(" Type \"#help\" for more information\n");
            std::string in;
            bool repl_flag = true;

            while (repl_flag) {
                fmt::print("{}>>> ", "" /* single icon indicating state */);
                std::getline(std::cin, in);
                // Remove leading/trailing whitespaces
                if (!in.compare("#quit")) { repl_flag = false; }
                else if (!in.compare("#help")) {
                    fmt::print("To use this interactive REPL, just type in regular code and hit\n");
                    fmt::print("enter. You can also make use of the following commands:\n\n");
                    //~ fmt::print("Loads variable and function declarations from a specified\n");
                    //~ fmt::print("					file into memory, e.g.\n");
                    //~ fmt::print("    >>> #load ~/hello_world.prog\n\n");
                    fmt::print(" #help				Display this text\n\n");
                    fmt::print(" #quit				Exits the REPL\n\n");
                    //~ fmt::print(" #st				Displays the symbol table, a
                    // list of
                    // currently declared \n");
                    //~ fmt::print("					functions and variables in
                    // the
                    // global scope.\n\n"); ~ fmt::print(" #clear Clears the terminal window.\n\n");
                }
            }
            return 0;
        }
    }
    // fmt::print(stderr, "Usage: {} <command> [args]\n", argv[0]);

    if (command->name == "help") {
        print_help(command->args.empty() ? "" : command->args[0]);
        return 0;
    }

    // Handle the different commands here.
    if (command->name == "test") {
        // Run tests.
        return 0;
    }
    else if (command->name == "new") {
        // Create a new module.
        return 0;
    }

    fmt::print("{}", about);
    fmt::print(stderr, "Unknown command: {}\n", command->name);
    // fmt::print(stderr, "Usage: {} <command> [args]\n", argv[0]);

    print_help(command->args.empty() ? "" : command->args[0]);

#if 0
#if HAS_COROUTINE
    coroutine_demo();
#endif // HAS_COROUTINE
#endif // 0
    return 1;
}
